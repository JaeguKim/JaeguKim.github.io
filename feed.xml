<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Programmer Digest</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-03-17T22:12:55+08:00</updated> <author> <name>JaeguKim</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 JaeguKim </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>SOLID</title><link href="/posts/solid/" rel="alternate" type="text/html" title="SOLID" /><published>2021-03-17T19:09:00+08:00</published> <updated>2021-03-17T19:09:00+08:00</updated> <id>/posts/solid/</id> <content src="/posts/solid/" /> <author> <name>JaeguKim</name> </author> <category term="SoftwareEngineering" /> <summary> SOLID Principle SRP(Single Responsibility Principle) : 단일 책임 원칙, 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다. OCP(Open-Closed Principle) : 개방-폐쇄 원칙, 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙, 상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램은 동작해야 한다. 예시 ISP(Interface Segregation Principle) : 클라이언트는 사용하지 않는 인터페이스에 의존해서는 안된다. DIP(Dependenc... </summary> </entry> <entry><title>DataFrame</title><link href="/posts/dataframe/" rel="alternate" type="text/html" title="DataFrame" /><published>2021-03-16T10:35:00+08:00</published> <updated>2021-03-16T10:35:00+08:00</updated> <id>/posts/dataframe/</id> <content src="/posts/dataframe/" /> <author> <name>JaeguKim</name> </author> <category term="DataEngineering" /> <category term="Spark" /> <summary> DataFrame named column으로 정리된 분산 데이터 컬렉션 Optimization, Code Generation 실행이 query optimizer에 의해 최적화된다. DataFrame에 대한 계산이 시작되기전에, Catalyst Optimizer가 DataFrame을 만드는 작업을 실행을 위한 physical plan으로 변환한다. 그리고 operation의 semantic과 데이터 구조를 분석하여, 계산을 빠르게 최적화한다. high level 관점에서 두가지 종류의 최적화가 존재한다. Catalyst는 predicate pushdown과 같은 logical optimization을 적용한다. optimizer는 filter predicate를 data source에 적용... </summary> </entry> <entry><title>Shuffle</title><link href="/posts/shuffle/" rel="alternate" type="text/html" title="Shuffle" /><published>2021-03-14T23:48:00+08:00</published> <updated>2021-03-15T20:37:45+08:00</updated> <id>/posts/shuffle/</id> <content src="/posts/shuffle/" /> <author> <name>JaeguKim</name> </author> <category term="DataEngineering" /> <category term="Spark" /> <summary> Spark Architecture: Shuffle Shuffle 이란 무엇일까? 하루에 발생한 전화량을 계산한다고 가정해보자. 이 경우 “day”를 key로 설정할것이고, 각각의 value는 1로 설정할것이다. 그리고 각각의 key에 대해서 value들을 합할것이다. 하지만 데이터를 클러스터에 저장할때, 같은 key에 대한 value들을 어떻게 계산할 수 있을까? 유일한 방법은 같은 key에 대한 value들이 같은 머신에 있도록 하는 방법 뿐이다. 이 주제를 논의하기에 앞서, 이 글에서는 MapReduce naming covention을 따르도록 하겠다. shuffle에서 source executor에서 데이터를 내보내는 task를 “mapper” 라 부르고 target executor로 데이... </summary> </entry> <entry><title>Cookie</title><link href="/posts/cookie/" rel="alternate" type="text/html" title="Cookie" /><published>2021-03-14T14:38:00+08:00</published> <updated>2021-03-14T14:38:00+08:00</updated> <id>/posts/cookie/</id> <content src="/posts/cookie/" /> <author> <name>JaeguKim</name> </author> <category term="Web" /> <summary> HTTP cookie 웹사이트를 브라우징 하면서 사용자의 컴퓨터에 저장되는 작은 데이터. web cooke, Internet cookie, browser cookie, or cookie 라고 부른다. 쿠키는 웹사이트가 사용자의 활동정보(특정 버튼 클릭, 로그인, 이전에 방문한 사이트 정보, online store에서 쇼핑 카트 정보)를 기억하기 위해서 사용된다. Session cookie 유저가 웹사이트를 이용중인동안에만 임시 메모리에 존재하는 cookie이다. 브라우저가 종료되면 보통 삭제된다. </summary> </entry> <entry><title>Transformation,Action</title><link href="/posts/transformationaction/" rel="alternate" type="text/html" title="Transformation,Action" /><published>2021-03-13T17:30:00+08:00</published> <updated>2021-03-13T22:38:34+08:00</updated> <id>/posts/transformationaction/</id> <content src="/posts/transformationaction/" /> <author> <name>JaeguKim</name> </author> <category term="DataEngineering" /> <category term="Spark" /> <summary> Transformation Operation 1. Transformation dataset을 함수에 전달하고 새로운 dataset을 리턴하는 작업 lazy evaluation 이고 action이 실행될때 실행된다. 두가지 기본타입은 map(),filter()이다. Narrow transformation - 하나의 파티션에서 일부만이 결과로 반환된다. Wide transformation - 하나의 파티션에 있는 데이터가 여러 파티션에 보내질수있다. 대표적으로 groupbyKey()와 reducebyKey가 있다. 2. Action driver program에 대한 마지막 결과를 리턴하거나 외부 저장소에 데이터를 기록한다. </summary> </entry> </feed>
